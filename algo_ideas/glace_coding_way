find LIS in sa.
if LIS is longer than 3, 
	push everything but the LIS to b.
else
	push everything to b until only three nbrs remain in a
	use function sort_three on sa.

calculate the best serie of rotation/push to push everything back to sa in order.


calculate best move
while sb not empty
	calculate, for each numbers in sb, the number of move they would need
	store the smallest nb of moves, update as needed
	bring the smallest on top of sb and it's pos on top of sa.
	push the number
	do it again til b is empty



calculate number of moves of an element : 

count the numbers of moves to bring it on top, see which direction (rb or rrb)
find the place where we shall put it
count the numbers of moves to bring the pos on top, see which direction
	if direction are the same, substract the number of common moves to the total number of move (rb rb rb ra ra ra ra is not 7 moves, but 4 : rr rr rr ra);
	return a struct containing the number of each moves (ra, rb, rr, rra, rrb, rrr);
