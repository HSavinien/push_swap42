Base concept : 
in any list of number, the longest sublist of already sorted number is called longest increasing subsequence (if sorted in ascending order). Any list of number might have at least one LIS (even if only one number long)

Basic algo : 

While (sA !sorted)
	Find LIS in sA
	Move LIS to top of sA (with ra or rra)
	move each number of the LIS to sB. If sB already have number, make it so sB stay sorted
//at that point, few number (maybe none) remain in sA, and they are all sorted. sB have probably way more values, and is already sorted too.

move, in order, each value from sB to sA, while making sure values already in sA stay in place

Improvement ideas : 
Rather than just searching for LIS, also search for the longest decreasing subsequence (LDS). If LDS is longer than LIS, we just move it in the opposite order. it would greatly optimise the code in the case where the list is roughly decreasing.